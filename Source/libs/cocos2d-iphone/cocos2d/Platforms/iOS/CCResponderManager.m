/*
 * cocos2d for iPhone: http://www.cocos2d-iphone.org
 *
 * Copyright (c) 2010 Ricardo Quesada
 * Copyright (c) 2011 Zynga Inc.
 * Copyright (c) 2013 Lars Birkemose
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *
 * File autogenerated with Xcode. Adapted for cocos2d needs.
 */

#import "CCResponderManager.h"
#import "CCNode.h"
#import "CCDirector.h"
#import "CCScene.h"

// -----------------------------------------------------------------
#pragma mark -
// -----------------------------------------------------------------

@implementation CCTouch

@end

// -----------------------------------------------------------------
#pragma mark -
// -----------------------------------------------------------------

@implementation CCResponderManager
{
    __weak CCNode*          _responderList[CCResponderManagerBufferSize];
    int                     _responderCount;
    NSMutableArray*         _touchList;                             // list of running touches
}

// -----------------------------------------------------------------
#pragma mark - create and destroy
// -----------------------------------------------------------------

+ (id)responderManager
{
    return([[self alloc] init]);
}

- (id)init
{
    self = [super init];
    NSAssert(self != nil, @"Unable to create class");
    
    // initalize
    _touchList = [NSMutableArray array];
        
    // reset touch handling
    [self removeAllResponders];
    
    // done
    return(self);
}

// -----------------------------------------------------------------
#pragma mark - add and remove touch responders
// -----------------------------------------------------------------

- (void)addResponder:(CCNode *)responder
{
    _responderList[_responderCount] = responder;
    _responderCount ++;
    NSAssert(_responderCount < CCResponderManagerBufferSize, @"Number of touchable nodes pr. scene can not exceed <%d>", CCResponderManagerBufferSize);
}

- (void)removeAllResponders
{    
    _responderCount = 0;
}

// -----------------------------------------------------------------
#pragma mark - iOS touch handling -
// -----------------------------------------------------------------

#if TARGET_OS_IPHONE || TARGET_IPHONE_SIMULATOR

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    BOOL responderCanAcceptTouch;
    
    [self buildResponderList];
    
    // go through all touches
    for (UITouch *touch in touches)
    {
        // scan backwards through touch responders
        for (int index = _responderCount - 1; index >= 0; index --)
        {
            CCNode *node = _responderList[index];
            
            // check for hit test
            if ([node hitTestWithWorldPos:[[CCDirector sharedDirector] convertToGL:[touch locationInView:[CCDirector sharedDirector].view]]] != NO)
            {
                // if not a multi touch node, check if node already is being touched
                responderCanAcceptTouch = YES;
                if (node.isMultipleTouchEnabled == NO)
                {
                    // scan current touch objects, and break if object already has a touch
                    for (CCTouch *touchEntry in _touchList) if (touchEntry.node == node)
                    {
                        responderCanAcceptTouch = NO;
                        break;
                    }
                }                
                if (responderCanAcceptTouch == NO) break;
                
                // begin the touch
                self.eventProcessed = YES;
                if ([node respondsToSelector:@selector(touchesBegan:withEvent:)] != NO)
                    [node touchesBegan:[NSSet setWithObject:touch] withEvent:event];
 
                // if touch was processed, add it and break
                if (self.eventProcessed != NO)
                {
                    [self addtouchResponder:node withTouch:touch andEvent:event];
                    break;
                }
            }
        }
    }
}

// -----------------------------------------------------------------

- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
{
    [self buildResponderList];

    // go through all touches
    for (UITouch *touch in touches)
    {
        // get touch object
        CCTouch *touchEntry = [self touchResponderForEvent:event];
        
        // if a touch object was found
        if (touchEntry != nil)
        {
            // check if it locks touches
            if (touchEntry.node.isTouchLocked != NO)
            {
                // move the touch
                if ([touchEntry.node respondsToSelector:@selector(touchesMoved:withEvent:)] != NO)
                    [touchEntry.node touchesMoved:[NSSet setWithObject:touch] withEvent:event];
            }
            else
            {
                // as node does not lock touch, check if it was moved outside
                if ([touchEntry.node hitTestWithWorldPos:[[CCDirector sharedDirector] convertToGL:[touch locationInView:[CCDirector sharedDirector].view]]] == NO)
                {
                    // cancel the touch
                    if ([touchEntry.node respondsToSelector:@selector(touchesCancelled:withEvent:)] != NO)
                        [touchEntry.node touchesCancelled:[NSSet setWithObject:touch] withEvent:event];
                    // remove from list
                    [_touchList removeObject:touchEntry];
                }
                else
                {
                    // move the touch
                    if ([touchEntry.node respondsToSelector:@selector(touchesMoved:withEvent:)] != NO)
                        [touchEntry.node touchesMoved:[NSSet setWithObject:touch] withEvent:event];
                }
            }
        }
        else
        {
            // scan backwards through touch responders
            for (int index = _responderCount - 1; index >= 0; index --)
            {
                CCNode *node = _responderList[index];
            
                // if the touch responder does not lock touch, it will receive a touchesBegan if a touch is moved inside
                if ((node.isTouchLocked == NO) && ([node hitTestWithWorldPos:[[CCDirector sharedDirector] convertToGL:[touch locationInView:[CCDirector sharedDirector].view ]]] != NO))
                {
                    // begin the touch
                    self.eventProcessed = YES;
                    if ([node respondsToSelector:@selector(touchesBegan:withEvent:)] != NO)
                        [node touchesBegan:[NSSet setWithObject:touch] withEvent:event];
                    
                    // if touch was accepted, add it and break
                    if (self.eventProcessed != NO)
                    {
                        [self addtouchResponder:node withTouch:touch andEvent:event];
                        break;
                    }
                }
            }
        }
    }
}

// -----------------------------------------------------------------

- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event
{
    [self buildResponderList];

    // go through all touches
    for (UITouch *touch in touches)
    {
        // get touch object
        CCTouch *touchEntry = [self touchResponderForEvent:event];
        
        if (touchEntry != nil)
        {
            // end the touch
            if ([touchEntry.node respondsToSelector:@selector(touchesEnded:withEvent:)] != NO)
                [touchEntry.node touchesEnded:[NSSet setWithObject:touch] withEvent:event];
            // remove from list
            [_touchList removeObject:touchEntry];
        }
    }
}

// -----------------------------------------------------------------

- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event
{
    [self buildResponderList];

    // go through all touches
    for (UITouch *touch in touches)
    {
        // get touch object
        CCTouch *touchEntry = [self touchResponderForEvent:event];
        
        if (touchEntry != nil)
        {
            // cancel the touch
            NSLog(@"Cancelled with <%d> touch responder(s)", _touchList.count);
            if ([touchEntry.node respondsToSelector:@selector(touchesCancelled:withEvent:)] != NO)
                [touchEntry.node touchesCancelled:[NSSet setWithObject:touch] withEvent:event];
            // remove from list
            [_touchList removeObject:touchEntry];
        }
    }
}

// -----------------------------------------------------------------
#pragma mark - helper functions
// -----------------------------------------------------------------
// finds a touch object for an event

- (CCTouch *)touchResponderForEvent:(UIEvent *)event
{
    for (CCTouch *touchEntry in _touchList)
    {
        if (touchEntry.event == event) return(touchEntry);
    }
    return(nil);
}

// -----------------------------------------------------------------
// finds a touch object for a node

- (NSSet *)touchSetForNode:(CCNode *)node
{
    NSMutableSet *result = [NSMutableSet set];
    for (CCTouch *touchEntry in _touchList)
    {
        if (touchEntry.node == node) [result addObject:touchEntry.touch];
    }
    return(result);
}

// -----------------------------------------------------------------
// adds a touch object ( running touch ) to the touch object list

- (void)addtouchResponder:(CCNode *)node withTouch:(UITouch *)touch andEvent:(UIEvent *)event
{
    CCTouch *touchEntry;
    
    // create a new touch object
    touchEntry = [[CCTouch alloc] init];
    touchEntry.node = node;
    touchEntry.touch = touch;
    touchEntry.event = event;
    [_touchList addObject:touchEntry];
}

// -----------------------------------------------------------------

- (void)buildResponderList
{
    // rebuild touch list
    // TODO: only rebuild if dirty
    [self removeAllResponders];
    [[CCDirector sharedDirector].runningScene buildResponderList];
}

// -----------------------------------------------------------------

#else

// -----------------------------------------------------------------
#pragma mark - Mac mouse handling -
// -----------------------------------------------------------------

- (void)mouseDown:(NSEvent *)theEvent
{

}

// -----------------------------------------------------------------

#endif

@end






































